// FGD file for pogo3D! this is one of the tools you need to make custom levels!

@SolidClass = worldspawn : "World Entity"
[
    mapname(string) : "Map Title"
]

@baseClass = Angles
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0"
]
@baseclass = Targetname [ targetname(target_source) : "Name" ]
@baseclass = Target [ target(target_destination) : "Target" ]

// SolidClasses that inherit this have a default texture that overrides what you set in trenchbroom
@baseclass = RenderStyle [
	renderstyle(choices) : "Render Style" : 0 =
	[
		0: "Default"
		1: "Invisible"
		2: "Use Map Texture"
	]
]

@baseclass size(-16 -16 0, 16 16 48) = PlayerClass []
@baseclass size(-16 -16 0, 16 16 32) = ItemPickup []

// Break on first contact with stick or face
@SolidClass = func_breakable : "Func Breakable" [
	resetondeath(choices) : "Reset On Death" : 0 =
	[
		0: "Don't Reset"
		1: "Reset"
	]
]

// You can see it, but you can't bounce off of it
@SolidClass = func_illusionary : "Func Illusionary" []

// You can't see it, but you can bounce off of it
@SolidClass = func_invisible : "Func Invisible" []

// Moving Platforms
@SolidClass = func_train : "Func Train"
[
	// point to an info_track_start 
	trackstart(target_destination) : "Train Track Start"
	// evenly space this many of this train brushes along the track.   
	carcount(int) : "Train Car Count" : 1
	// unfortunately moving platforms don't support material sounds :(
	// you have to manually specify the sound effect here
	// values are the same as the ones for .metawad files
	surface(string) : "Surface Sound Type" : "default"
]

// opens when you touch it after getting enough pennies
@SolidClass base(RenderStyle) = func_unlockable_coin : "Unlockable Door (Coin)"
[
	// This can be as high as you want, but the door only shows up to the value 15.
	// so ideally do not go over 15 coins. 1-5 is a good value here
	coins_required(int): "Coins Required" : 1
]

// opens when you touch it after getting the key of the right color
@SolidClass base(RenderStyle) = func_unlockable_key : "Unlockable Door (Key)"
[
	key_color(choices): "Key Color" : 1 =
	[
		1: "Red"
		2: "Blue"
		3: "Yellow"
	]
]

@PointClass base(trackoptions, Targetname, Target) = info_track_start : "Train Track Start"
[
]
@PointClass base(trackoptions, Targetname, Target) = info_track : "Train Track" []
@baseClass = trackoptions
[
	// how long to wait at this spot in milliseconds
	stoptime(int) : "Stop Time (ms)" : 0
	// how long should it take to reach the next stop in the sequence
	traveltime(int) : "Segment Travel Time (ms)" : 1000
	// next track in the sequence (can be left empty for non-looping tracks)
	// target(target_destination)
	easing(choices) : "Next Segment Easing" : 0 =
	[
		0: "Linear"
		1: "Ease In"
		2: "Ease Out"
		3: "Ease In & Out"
	]
]

// Used by trigger_checkpoint and trigger_teleport to mark where the player respawns
@PointClass base(PlayerClass, Targetname)
    model({
        "path" : "models/info_player_respawn.mdl"
    })
     = info_player_respawn : "Respawn Point" []

// A mostly useless item you pick up when you touch it
@PointClass 
	base(ItemPickup)
	model({
		"path" : "models/item_penny.mdl"
	})
	= item_penny : "Penny" []

@PointClass 
	base(ItemPickup)
	model({
		"path" : "models/item_key_red.mdl"
	})
	= item_key_red : "Red Key" []
	
@PointClass 
	base(ItemPickup)
	model({
		"path" : "models/item_key_blue.mdl"
	})
	= item_key_blue : "Blue Key" []

@PointClass 
	base(ItemPickup)
	model({
		"path" : "models/item_key_yellow.mdl"
	})
	= item_key_yellow : "Yellow Key" []

// A Checkpoint!
@SolidClass base(Target, RenderStyle) = trigger_checkpoint : "Checkpoint"
[
	// This is the name of the info_player_respawn the player will appear at after respawning
	// This is optional! without one, the player will respawn in the middle of the checkpoint
	// target(target_destination)

	// IF AND ONLY IF there is no target for this checkpoint, specify the player's angle after respawn
	angle(integer) : "Generated Respawn Point Angle" : 0

	spawnflags(Flags) =
	[
		1 : "Can Skip" : 1
	]
	
	// Specify the type of this checkpoint
	// Main Path - automatically set up skipping for the next number in sequence.
	// Side Path - unskippable unless SkipTarget is set
	// The first "Main Path" Checkpoint will act as the spawn point
	pathtype(choices) : "Checkpoint Type" : 0 =
	[
		0: "Main Path"
		1: "Side Path"
	]
	// For Main Path checkpoints, The number of this checkpoint in sequence.
	// Does nothing for Side Path checkpoints
	number(integer) : "Checkpoint Number" : 1
	// the name of the info_player_respawn the player should teleport to on skip.
	skiptarget(target_destination) : "Override Skip Target"
]

// A Finish-Line trigger. You should probably put 1 at the end of your level.
// feel free to any number of these, or zero if you want
@SolidClass base(RenderStyle) = trigger_finish : "Finish Line" []

// Water. kills on contact with your hitbox
@SolidClass base(RenderStyle) = trigger_kill : "Trigger Kill"
[
	// What effect to play when you die
	// as you can see from reading this, it defaults to water
	killtype(choices) : "Kill Type" : 1 =
	[
		0: "Surface"
		1: "Water"
		2: "Space"
	]
]

// A zero gravity zone
@SolidClass base(RenderStyle) = trigger_gravity : "Trigger Gravity" []

// A "Flight Ring"
@SolidClass base(RenderStyle) = trigger_flight : "Trigger Flight" []

// A Teleporter
@SolidClass base(Target, RenderStyle) = trigger_teleport : "Trigger Teleport"
[
	// Target should be an info_player_respawn :) you can make one just for this teleport, or reuse one that a checkpoint is already using

	// What happens to your velocity and angle when you go through the teleporter?
	keep_phys(choices) : "Preserve Physics" : 0 =
	[
		// Appear at the other end like you just respawned
		0: "Don't Preserve"
		// Maintain angle and velocity
		1: "Preserve"
	]
	// 0-360 angle. if keep_phys = 1, rotate the player by this angle (clockwise)
	phys_angle(int) : "Preserve Physics Angle" : 0
]

//
// Cameras
//

@PointClass base(Angles) = info_camera_preview : "Preview Image Camera" []

//
// lights - straight from quake 1 but no AppearFlags
// lights don't do anything yet :( sorry
//

@baseclass color(255 255 40) = Light [
	light(integer) : "Brightness" : 300
	wait(integer) : "Fade distance multiplier" : 1
	delay(choices) : "Attenuation" =
	[
		0 : "Linear falloff (Default)"
		1 : "Inverse distance falloff"
		2 : "Inverse distance squared"
		3 : "No falloff"
		4 : "Local minlight"
		5 : "Inverse distance squared B"
	]
	mangle(string) : "Spotlight angle"
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
]

@PointClass size(-8 -8 -8, 8 8 8) base(Light, Target, Targetname) =
	light : "Invisible light source"
	[
	]